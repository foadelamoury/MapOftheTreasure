#include <thread>
#include <chrono>
#include <conio.h>
#include <fstream>
#include <cstdlib>
#include <random>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int player_x = 1, player_y = 1;
int treasure_x = 18, treasure_y = 8;
bool game_win = false;
vector<string> maze;  // To store the maze layout
int maze_height, maze_width;  // Dynamically determined height and width

void gotoXY(int x, int y) {
    cout << "\033[" << y + 1 << ";" << x + 1 << "H"; // Move cursor to (x, y)
}

void clearScreen() {
    cout << "\033[2J"; // Clear screen
}

void loadMaze() {
    std::ifstream mazeFile("maze.txt");
    if (!mazeFile) {
        std::cerr << "Error: Could not open maze file!" << std::endl;
        exit(1); // Exit if the file can't be opened
    }

    std::string line;
    while (std::getline(mazeFile, line)) {
        maze.push_back(line); // Load each line into the maze
    }
    mazeFile.close();

    // Determine maze height and width
    maze_height = maze.size();  // Number of rows
    maze_width = maze[0].length();  // Length of the first row (assuming uniform width)
}

void display() {
    clearScreen();
    for (int i = 0; i < maze.size(); i++) {
        cout << maze[i] << endl;
    }

    // Draw player and treasure
    gotoXY(player_x, player_y);
    cout << "P";
    gotoXY(treasure_x, treasure_y);
    cout << "X";
}

bool isCollision(int new_x, int new_y) {


    // Check if the new position contains '*' (wall)
    return maze[new_y][new_x] == '*';
}

void updatePlayerPosition(int prev_x, int prev_y) {
    // Clear previous player position
    gotoXY(prev_x, prev_y);
    cout << " ";

    // Draw new player position
    gotoXY(player_x, player_y);
    cout << "P";
}

int main() {
    loadMaze();  // Load the maze from the file and calculate bounds
    display();   // Display the maze initially

    do {
        if (_kbhit()) {
            int prev_x = player_x, prev_y = player_y; // Store previous position
            char key = _getch();
            int new_x = player_x, new_y = player_y;

            // Move player based on input
            switch (key) {
            case 'w': new_y--; break;  // Move up
            case 's': new_y++; break;  // Move down
            case 'a': new_x--; break;  // Move left
            case 'd': new_x++; break;  // Move right
            }

            // Check for collision and if the new position is within bounds
            if (!isCollision(new_x, new_y)) {
                player_x = new_x;
                player_y = new_y;

                // Update only the player's position
                updatePlayerPosition(prev_x, prev_y);
            }
        }

        // Check if the player found the treasure
        if (player_x == treasure_x && player_y == treasure_y) {
            gotoXY(0, maze_height); // Move cursor below the grid
            cout << "You found the treasure! You win!" << endl;
            game_win = true;
        }

    } while (!game_win);

    return 0;
}
